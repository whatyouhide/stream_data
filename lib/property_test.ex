defmodule PropertyTest do
  @moduledoc """
  Provides macros for property testing.
  """

  # TODO: moduledoc (overview of ptesting, shrinking)

  alias StreamData.Random

  defmodule RunOptions do
    @moduledoc false

    defstruct test_count: 100,
              max_shrink_depth: 50
  end

  defmodule Error do
    defexception [:original_failure, :shrinked_failure]

    def message(%{original_failure: original_failure, shrinked_failure: shrinked_failure}) do
      formatted_original = Exception.format_banner(:error, original_failure.exception, original_failure.stacktrace)
      formatted_original_indented = "  " <> String.replace(formatted_original, "\n", "\n  ")

      formatted_shrinked = Exception.format_banner(:error, shrinked_failure.failure.exception, shrinked_failure.failure.stacktrace)
      formatted_shrinked_indented = "  " <> String.replace(formatted_shrinked, "\n", "\n  ")

      formatted_values = "  " <> Enum.map_join(shrinked_failure.failure.generated_values, "\n\n  ", fn {gen_string, value} ->
        gen_string <> "\n  #=> " <> inspect(value)
      end)

      """
      property failed. Original failure:

      #{formatted_original_indented}

      Failure from shrinked data:

      #{formatted_shrinked_indented}

      Shrinked generated values:

      #{formatted_values}

      (visited a total of #{shrinked_failure.nodes_visited}, #{shrinked_failure.current_depth} level(s) deep)
      """
    end
  end

  @doc """
  Runs tests for a property.

  This macro provides ad hoc syntax to write properties. Let's see a quick
  example to get a feel of how it works:

      check all int1 <- int(),
                int2 <- int(),
                int1 > 0 and int2 > 0,
                sum = int1 + int2 do
        assert sum > int1
        assert sum > int2
      end

  Everything between `check all` and `do` is referred to as **clauses**. Clauses
  are used to specify the values to generate in order to test the properties.
  The actual tests that the properties hold live in the `do` block.

  ### Clauses

  As seen in the example above, clauses can be of three types:

    * value generation - they have the form `pattern <- generator` where
      `generator` must be a `StreamData` struct. These clauses take a value out
      of `generator` on each run and match it against `pattern`. Variables bound
      in `pattern` can be then used throughout subsequent clauses and in the
      `do` body.

    * binding - they have the form `pattern = expression`. They are exactly like
      assignment through the `=` operator: if `pattern` doesn't match
      `expression`, an error is raised. They can be used to bind values for use
      in subsequent clauses and in the `do` block.

    * filtering - they have the form `expression`. If a filtering clause returns
      a truthy value, then the set of generated values that appear before the
      filtering clause is considered valid and the execution of the current run
      is continued. If the filtering clause returns a falsey value, then the
      current run is considered invalid and a new run is started. Note that
      filtering clauses should not filter out too many times; in case they do, a
      `StreamData.FilterTooNarrowError` error is raised.

  ### Body

  The body passed in the `do` block is where you test that the property holds
  for the generated values. The body is just like the body of a test: use
  `ExUnit.Assertions.assert/2` (and friends) to assert whatever you want.

  ## Shrinking

  See the module documentation for more information on shrinking. Clauses affect
  shrinking in the following way:

    * binding clauses don't affect shrinking
    * filtering clauses affect shrinking like `StreamData.filter/3`
    * value generation clauses affect shrinking similarly to `StreamData.bind/2`

  ## Examples

  Check that all values generated by the `StreamData.int/0` generator are
  integers:

      check all int <- int() do
        assert is_integer(int)
      end

  Check that `String.starts_with?/2` and `String.ends_with?/2` always holds for
  concatenated strings:

      check all start <- binary(),
                end <- binary(),
                concat = start <> end do
        assert String.starts_with?(concat, start)
        assert String.ends_with?(concat, end)
      end

  Check that `Kernel.in/2` returns `true` when checking if an element taken out
  of a list is in that same list:

      check all list <- list_of(int()),
                member <- member_of(list) do
        assert member in list
      end

  """
  defmacro check({:all, _meta, clauses} = generation_clauses, [do: body] = block) when is_list(clauses) do
    quote do
      property = unquote(Property.compile(clauses, body))
      starting_seed = Random.new_seed(ExUnit.configuration()[:seed])
      PropertyTest.run_property(property, starting_seed, _initial_size = 0, %RunOptions{})
    end
  end

  @doc false
  def run_property(property, initial_seed, initial_size, %RunOptions{} = run_options) do
    state = %{successes: 0}
    run_property(property, initial_seed, initial_size, state, run_options)
  end

  defp run_property(_property, _seed, _size, %{successes: n}, %RunOptions{test_count: n}) do
    :ok
  end

  defp run_property(property, seed, size, state, options) do
    {seed1, seed2} = Random.split(seed)

    tree = StreamData.call(property, seed1, size)

    case tree.root.() do
      %Property.Success{} ->
        state = Map.update!(state, :successes, &(&1 + 1))
        run_property(property, seed2, size + 1, state, options)
      %Property.Failure{} = original_failure ->
        shrinked_failure = shrink_failure(tree.children, _smallest = original_failure, _nodes_visited = 0, _current_depth = 0, options.max_shrink_depth)
        raise Error, original_failure: original_failure, shrinked_failure: shrinked_failure
    end
  end

  defp shrink_failure(nodes, smallest, nodes_visited, current_depth, max_depth) do
    if current_depth == max_depth or Enum.empty?(nodes) do
      %{failure: smallest, nodes_visited: nodes_visited, current_depth: current_depth}
    else
      [first_child] = Enum.take(nodes, 1)

      case first_child.root.() do
        %Property.Success{} ->
          shrink_failure(Stream.drop(nodes, 1), smallest, nodes_visited + 1, current_depth, max_depth)
        %Property.Failure{} = failure ->
          if Enum.empty?(first_child.children) do
            shrink_failure(Stream.drop(nodes, 1), failure, nodes_visited + 1, current_depth, max_depth)
          else
            shrink_failure(first_child.children, failure, nodes_visited + 1, current_depth + 1, max_depth)
          end
      end
    end
  end
end
